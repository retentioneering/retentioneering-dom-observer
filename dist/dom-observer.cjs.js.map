{"version":3,"file":"dom-observer.cjs.js","sources":["../src/DomParser.ts","../src/EventEmitter.ts","../src/DomObserver.ts","../src/DomCollector.ts"],"sourcesContent":["/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\ntype ParseTarget = \"textContent\" | string\n\ntype ParserConfigObject = {\n    type: \"object\"\n    keys: {\n        key: string\n        value: ParserConfig\n    }[]\n}\n\ntype ParserConfigArray = {\n    type: \"array\"\n    selector: string\n    parseFrom?: ParseTarget\n    items?: ParserConfig\n}\n\ntype ParserConfigString = {\n    type: \"string\"\n    selector?: string\n    parseFrom?: ParseTarget\n    formatter?: (value: string | null, el: HTMLElement | null) => any\n}\n\ntype ParseConfigBoolean = {\n    type: \"boolean\"\n    selector: string\n    inverse?: boolean\n}\n\ntype ParseConfigCount = {\n    type: \"count\"\n    selector: string\n}\n\ntype ParseConfigNumber = {\n    type: \"number\"\n    selector?: string\n    parseFrom?: ParseTarget\n    formatter: (\n        value: string | null, el: HTMLElement | Document | null\n    ) => number | null\n}\n\nexport type ParserConfig =\n    | ParserConfigObject\n    | ParserConfigArray\n    | ParserConfigString\n    | ParseConfigBoolean\n    | ParseConfigNumber\n    | ParseConfigCount\n\nexport type ParseDomResult =\n    | string\n    | null\n    | boolean\n    | number\n    | Array<ParseDomResult>\n    | {\n        [key: string]: ParseDomResult\n    }\n\n\nconst parseText = (\n    el: HTMLElement | Document,\n    parseFrom?: ParseTarget\n) => {\n    if (!parseFrom || (parseFrom === \"textContent\")) {\n        return el.textContent\n    }\n    if (typeof parseFrom === \"string\" && el instanceof HTMLElement) {\n        return el.getAttribute(parseFrom)\n    }\n    return null\n}\n\n/**\n * Parse a specific structure from the DOM recursively\n * @param  config - configuration object that describes the type of the resulting object and how to get it from the DOM\n * @param  rootElement - root DOM element. will be parsed inside the children of this element\n * @return result of parsing\n */\nexport function parseDOM(\n    config: ParserConfig,\n    rootElement?: HTMLElement\n): ParseDomResult {\n    if (config.type === \"string\") {\n        const parentElement = rootElement || window.document\n        if (!config.selector) {\n            return parseText(parentElement, config.parseFrom)\n        }\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        const value =  targetElement\n            ? parseText(targetElement, config.parseFrom)\n            : null\n        return config.formatter ? config.formatter(value, targetElement) : value\n    }\n    if (config.type === \"count\") {\n        const parentElement = rootElement || window.document\n        const targetElements = parentElement.querySelectorAll<HTMLElement>(\n            config.selector\n        )\n        return targetElements.length\n    }\n    if (config.type === \"number\") {\n        const parentElement = rootElement || window.document\n        if (!config.selector) {\n            const value = parseText(parentElement, config.parseFrom)\n            return config.formatter(value, parentElement)\n        }\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        const value = targetElement\n            ? parseText(targetElement, config.parseFrom) : null\n        return config.formatter(value, targetElement)\n    }\n\n    if (config.type === \"boolean\") {\n        const parentElement = rootElement || window.document\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        const targetElementExists = Boolean(targetElement)\n        return !config.inverse ? targetElementExists : !targetElementExists\n    }\n    if (config.type === \"array\") {\n        const parentElement = rootElement || window.document\n        const mathedElems = parentElement.querySelectorAll<HTMLElement>(\n            config.selector\n        )\n        if (config.items) {\n            const values = [] as ParseDomResult[]\n            for (const el of mathedElems) {\n                values.push(parseDOM(config.items, el))\n            }\n            return values\n        } else {\n            return [...mathedElems].map(\n                (el: HTMLElement) => parseText(el, config.parseFrom)\n            )\n        }\n    }\n    if (config.type === \"object\") {\n        const result = {} as { [key: string]: ParseDomResult }\n        for (const { key, value } of config.keys) {\n            result[key] = parseDOM(value, rootElement)\n        }\n        return result\n    }\n    return null\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\ntype EventHadler<P = any> = (p: P) => any\n\ntype Event = {\n    eventName: string\n    handlers: EventHadler[]\n}\n\n/* Simple EventEmitter */\nexport class EventEmitter {\n    private events: Event[] = []\n\n    private createUnwatcher<P = any>(\n        eventName: string,\n        handler: EventHadler<P>\n    ) {\n        return () => {\n            for (let i = 0; i < this.events.length; i++) {\n                const event = this.events[i]\n                event.handlers = event.handlers.filter(\n                    existingHandler => existingHandler !== handler\n                )\n                if (event.handlers.length) continue\n                this.events.splice(i, 1)\n                i--\n            }\n        }\n    }\n\n    public on<P = any>(eventName: string, handler: EventHadler<P>) {\n        const unwatch = this.createUnwatcher<P>(eventName, handler)\n\n        const existingEvent = this.events.find(\n            found => found.eventName === eventName\n        )\n        if (existingEvent && existingEvent.handlers.includes(handler)) {\n            return unwatch\n        } else if (existingEvent) {\n            existingEvent.handlers.push(handler)\n        } else {\n            this.events.push({ eventName, handlers: [handler] })\n        }\n        return unwatch\n    }\n\n    public off<P = any>(eventName: string, handler: EventHadler<P>) {\n        const unwatch = this.createUnwatcher(eventName, handler)\n        unwatch()\n    }\n\n    public dispatch<P = any>(eventName: string, payload?: P) {\n        const event = this.events.find(event => event.eventName === eventName)\n        if (event) {\n            for (const handler of event.handlers) {\n                handler(payload)\n            }\n        }\n    }\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\nimport { EventEmitter } from \"./EventEmitter\"\n\nconst MAIN_OBSERVER_CONFIG = {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: false,\n    characterDataOldValue: false,\n    attributeOldValue: false,\n}\n\ntype TargetElementDescriptor = {\n    name: string\n    selector: string\n    observerConfig?: MutationObserverInit\n}\n\ntype TargetElementsObserver = {\n    descriptor: TargetElementDescriptor\n    observers: MutationObserver[]\n}\n\ntype ObservedElement = {\n    element: HTMLElement\n    descriptor: TargetElementDescriptor\n}\n\nexport const FOUND_EVENT_NAME = \"target-element-found\"\nexport const MUTATED_EVENT_NAME = \"target-element-mutated\"\n\nexport type FoundEvent = {\n    type: typeof FOUND_EVENT_NAME\n    descriptor: TargetElementDescriptor\n    element: HTMLElement\n}\n\nexport type MutatedEvent = {\n    type: typeof MUTATED_EVENT_NAME\n    descriptor: TargetElementDescriptor\n    mutations: MutationRecord[]\n}\n\nexport type ObserveDomEvent = FoundEvent | MutatedEvent\n\nexport type MainObserverCb = (mutations: MutationRecord[]) => void\n\ntype SubscribeCb = (e: ObserveDomEvent) => void\n\nexport class DomObserver extends EventEmitter {\n    private _mainObserver: MutationObserver | null = null\n    private _observedElements: ObservedElement[] = []\n    private _targetElementsObservers: TargetElementsObserver[] = []\n    private _targetElementsDescriptors: TargetElementDescriptor[] = []\n    private _checkTargetSelectorAndObserve(\n        descriptor: TargetElementDescriptor,\n        el: HTMLElement,\n        mutationsList: MutationRecord[],\n    ) {\n        const targetElements = el.matches(descriptor.selector)\n            ? [el]\n            : [...el.querySelectorAll<HTMLElement>(descriptor.selector)]\n\n        if (!targetElements.length) {\n            return\n        }\n\n        this._observeTargetElements(targetElements, descriptor)\n\n        // check if the mutation of the target node is in the mutations list\n        const matchedMutations = this._matchTargetElementMutations(\n            descriptor,\n            mutationsList\n        )\n        if (matchedMutations.length) {\n            this._dispatchMutatedEvent(matchedMutations, descriptor)\n        }\n    }\n    private _matchTargetElementMutations(\n        descriptor: TargetElementDescriptor,\n        mutationsList: MutationRecord[]\n    ) {\n        const matchedMutations = []\n        for (const mutation of mutationsList) {\n            if ((mutation.target as HTMLElement).closest(descriptor.selector)) {\n                matchedMutations.push(mutation)\n            }\n        }\n        return matchedMutations\n    }\n    private _observeTargetElements(\n        elems: HTMLElement[],\n        descriptor: TargetElementDescriptor\n    ) {\n        const observer = new window.MutationObserver(mutations =>\n            this._onTargetElementMutated(mutations, descriptor)\n        )\n        for (const elem of elems) {\n            const alreadyObserved = this._observedElements.some(\n                ({ descriptor: foundDescriptor, element }) => {\n                    return descriptor.name === foundDescriptor.name && element === elem\n                }\n            )\n            if (alreadyObserved) continue\n            this._observedElements.push({\n                element: elem,\n                descriptor,\n            })\n            this._dispatchFoundEvent(descriptor, elem)\n            observer.observe(elem, descriptor.observerConfig)\n        }\n        const existingObserverItem = this._targetElementsObservers.find(\n            found => found.descriptor.name === descriptor.name\n        )\n        if (existingObserverItem) {\n            existingObserverItem.observers.push(observer)\n        } else {\n            this._targetElementsObservers.push({\n                descriptor,\n                observers: [observer],\n            })\n        }\n    }\n    private _onTargetElementMutated(\n        mutations: MutationRecord[],\n        descriptor: TargetElementDescriptor\n    ) {\n        this._dispatchMutatedEvent(mutations, descriptor)\n    }\n    private _dispatchMutatedEvent(\n        mutations: MutationRecord[],\n        descriptor: TargetElementDescriptor\n    ) {\n        const payload: MutatedEvent = {\n            type: MUTATED_EVENT_NAME,\n            descriptor,\n            mutations,\n        }\n        this.dispatch(\"target-element-mutated\", payload)\n    }\n    private _dispatchFoundEvent(\n        descriptor: TargetElementDescriptor,\n        element: HTMLElement\n    ) {\n        const payload: FoundEvent = {\n            type: FOUND_EVENT_NAME,\n            descriptor,\n            element,\n        }\n        this.dispatch(\"target-element-found\", payload)\n    }\n    private _onRootElementMutated = (mutationsList: MutationRecord[]) => {\n        for (const mutation of mutationsList) {\n            if (mutation.type !== \"childList\") continue\n            for (const node of mutation.addedNodes) {\n                if (!(node instanceof window.HTMLElement)) continue\n                for (const descriptor of this._targetElementsDescriptors) {\n                    this._checkTargetSelectorAndObserve(\n                        descriptor,\n                        node,\n                        mutationsList\n                    )\n                }\n            }\n\n            this._clearObservedElementsByMutation(mutation)\n        }\n    }\n    private _clearObservedElementsByMutation(mutation: MutationRecord) {\n        this._observedElements = this._observedElements.filter(\n            ({ element }) => {\n                return ![...mutation.removedNodes].includes(element)\n            }\n        )\n    }\n    private _clearObservedElementsByDescriptor(\n        descriptor: TargetElementDescriptor\n    ) {\n        this._observedElements = this._observedElements.filter(\n            ({ descriptor: foundDescriptor }) => {\n                return descriptor.name !== foundDescriptor.name\n            }\n        )\n    }\n    constructor(private _rootElement: HTMLElement = document.body) {\n        super()\n    }\n    get observedElements() {\n        return [...this._observedElements]\n    }\n    public start(cb?: MainObserverCb) {\n        this._mainObserver = new window.MutationObserver(mutations => {\n            this._onRootElementMutated(mutations)\n            if (cb) {\n                cb(mutations)\n            }\n        })\n        this._mainObserver.observe(this._rootElement, MAIN_OBSERVER_CONFIG)\n        return this\n    }\n    public stop() {\n        if (this._mainObserver) {\n            this._mainObserver.disconnect()\n            this._onRootElementMutated(this._mainObserver.takeRecords())\n            this._mainObserver = null\n        }\n        this.stopObservation()\n        return this\n    }\n    public subscribe(cb: SubscribeCb, descriptor?: TargetElementDescriptor) {\n        const handleEvent = (e: ObserveDomEvent) => {\n            if (!descriptor) {\n                cb(e)\n                return\n            }\n            if (descriptor.name === e.descriptor.name) {\n                cb(e)\n            }\n        }\n        this.on<MutatedEvent>(MUTATED_EVENT_NAME, handleEvent)\n        this.on<FoundEvent>(FOUND_EVENT_NAME, handleEvent)\n        return () => {\n            this.off(MUTATED_EVENT_NAME, handleEvent)\n            this.off(FOUND_EVENT_NAME, handleEvent)\n        }\n    }\n    public stopObservation(name?: string) {\n        for (let i = 0; i < this._targetElementsObservers.length; i++) {\n            const targetElementObserver = this._targetElementsObservers[i]\n            if (name && targetElementObserver.descriptor.name !== name) continue\n\n            this._clearObservedElementsByDescriptor(\n                targetElementObserver.descriptor\n            )\n\n            for (const mObserver of targetElementObserver.observers) {\n                const unhandledRecords = mObserver.takeRecords()\n                if (unhandledRecords.length) {\n                    this._onTargetElementMutated(\n                        unhandledRecords,\n                        targetElementObserver.descriptor\n                    )\n                }\n                mObserver.disconnect()\n            }\n            this._targetElementsObservers.splice(i, 1)\n            i--\n        }\n        if (!name) {\n            this._targetElementsDescriptors = []\n            return this\n        }\n        const updatedDescriptors = this._targetElementsDescriptors.filter(\n            found => found.name !== name\n        )\n        this._targetElementsDescriptors = updatedDescriptors\n        return this\n    }\n    public observe(descriptor: TargetElementDescriptor) {\n        this._targetElementsDescriptors.push(descriptor)\n        // element already exists\n        const targetElements = [\n            ...this._rootElement.querySelectorAll<HTMLElement>(\n                descriptor.selector\n            ),\n        ]\n        if (targetElements.length) {\n            this._observeTargetElements(targetElements, descriptor)\n        }\n        return this\n    }\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\nimport { DomObserver, MainObserverCb } from \"./DomObserver\"\nimport { parseDOM, ParserConfig, ParseDomResult } from \"./DomParser\"\n\nexport type DomCollectorTarget = {\n    name: string\n    targetSelector: string\n    guardSelector?: string\n    childGuardSelector?: string\n    guard?: (rootElement: HTMLElement) => boolean\n    parseRootEl: string | HTMLElement\n    observeConfig?: MutationObserverInit\n    parseConfig: ParserConfig\n    payload?: any\n    mapResult?: (parsedContent: any) => any\n}\n\ntype DomCollectorResult = {\n    name: string\n    payload?: any\n    parsedContent: any\n}\n\ntype Params = {\n    targets: DomCollectorTarget[]\n    onCollect: (result: DomCollectorResult) => void\n    rootEl?: HTMLElement\n    mainObserverCallback?: MainObserverCb\n}\n\nconst DEFAULT_OBSERVER_CONFIG = {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: false,\n    characterDataOldValue: false,\n    attributeOldValue: false,\n}\n\nexport const createDomCollector = ({\n    targets,\n    onCollect,\n    rootEl,\n    mainObserverCallback,\n}: Params) => {\n    const domObserver = new DomObserver(rootEl || document.body)\n    \n    domObserver.start(mainObserverCallback)\n    \n    for (const target of targets) {\n        const { mapResult } = target\n\n        const observeDescriptor = {\n            name: target.name,\n            selector: target.targetSelector,\n            observerConfig: target.observeConfig || DEFAULT_OBSERVER_CONFIG,\n        }\n        domObserver.subscribe((e) => {\n            const { guardSelector, childGuardSelector, guard } = target\n            if (!guardSelector || document.querySelector(guardSelector)) {\n                const parseRootEl =\n                    typeof target.parseRootEl === \"string\"\n                        ? document.querySelector<HTMLElement>(\n                            target.parseRootEl\n                        )\n                        : target.parseRootEl\n                if (!parseRootEl) {\n                    return\n                }\n\n                if (childGuardSelector \n                    && !parseRootEl.querySelector(childGuardSelector)) {\n                    return\n                }\n\n                if (guard && !guard(parseRootEl)) {\n                    return\n                }\n\n                const parsedContent = parseDOM(target.parseConfig, parseRootEl)\n                onCollect({\n                    name: target.name,\n                    payload: target.payload,\n                    parsedContent: mapResult\n                        ? mapResult(parsedContent)\n                        : parsedContent,\n                })\n            }\n        }, observeDescriptor)\n        domObserver.observe(observeDescriptor)\n    }\n\n    return domObserver\n}\n"],"names":["parseText","el","parseFrom","HTMLElement","getAttribute","textContent","parseDOM","config","rootElement","type","parentElement","window","document","selector","targetElement","querySelector","value","formatter","querySelectorAll","length","targetElementExists","Boolean","inverse","mathedElems","items","values","push","map","result","key","keys","EventEmitter","[object Object]","this","eventName","handler","i","events","event","handlers","filter","existingHandler","splice","unwatch","createUnwatcher","existingEvent","find","found","includes","payload","MAIN_OBSERVER_CONFIG","attributes","childList","subtree","characterData","characterDataOldValue","attributeOldValue","DomObserver","_rootElement","body","super","mutationsList","mutation","node","addedNodes","descriptor","_targetElementsDescriptors","_checkTargetSelectorAndObserve","_clearObservedElementsByMutation","targetElements","matches","_observeTargetElements","matchedMutations","_matchTargetElementMutations","_dispatchMutatedEvent","target","closest","elems","observer","MutationObserver","mutations","_onTargetElementMutated","elem","_observedElements","some","foundDescriptor","element","name","_dispatchFoundEvent","observe","observerConfig","existingObserverItem","_targetElementsObservers","observers","dispatch","removedNodes","observedElements","cb","_mainObserver","_onRootElementMutated","disconnect","takeRecords","stopObservation","handleEvent","e","on","off","targetElementObserver","_clearObservedElementsByDescriptor","mObserver","unhandledRecords","updatedDescriptors","DEFAULT_OBSERVER_CONFIG","targets","onCollect","rootEl","mainObserverCallback","domObserver","start","mapResult","observeDescriptor","targetSelector","observeConfig","subscribe","guardSelector","childGuardSelector","guard","parseRootEl","parsedContent","parseConfig"],"mappings":"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"}