{"version":3,"file":"dom-observer.es.js","sources":["../src/DomParser.ts","../src/EventEmitter.ts","../src/DomObserver.ts","../src/DomCollector.ts"],"sourcesContent":["/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\ntype ParseTarget = \"textContent\" | string\n\ntype ParserConfigObject = {\n    type: \"object\"\n    keys: {\n        key: string\n        value: ParserConfig\n    }[]\n}\n\ntype ParserConfigArray = {\n    type: \"array\"\n    selector: string\n    parseFrom?: ParseTarget\n    items?: ParserConfig\n}\n\ntype ParserConfigString = {\n    type: \"string\"\n    selector?: string\n    parseFrom?: ParseTarget\n    formatter?: (value: string | null, el: Element | null) => any\n}\n\ntype ParseConfigBoolean = {\n    type: \"boolean\"\n    selector: string\n    inverse?: boolean\n}\n\ntype ParseConfigCount = {\n    type: \"count\"\n    selector: string\n}\n\ntype ParseConfigNumber = {\n    type: \"number\"\n    selector?: string\n    parseFrom?: ParseTarget\n    formatter: (\n        value: string | null, el: Element | Document | null\n    ) => number | null\n}\n\nexport type ParserConfig =\n    | ParserConfigObject\n    | ParserConfigArray\n    | ParserConfigString\n    | ParseConfigBoolean\n    | ParseConfigNumber\n    | ParseConfigCount\n\nexport type ParseDomResult =\n    | string\n    | null\n    | boolean\n    | number\n    | Array<ParseDomResult>\n    | {\n        [key: string]: ParseDomResult\n    }\n\n\nconst parseText = (\n    el: Element | Document,\n    parseFrom?: ParseTarget\n) => {\n    if (!parseFrom || (parseFrom === \"textContent\")) {\n        return el.textContent\n    }\n    if (typeof parseFrom === \"string\" && el instanceof Element) {\n        return el.getAttribute(parseFrom)\n    }\n    return null\n}\n\n/**\n * Parse a specific structure from the DOM recursively\n * @param  config - configuration object that describes the type of the resulting object and how to get it from the DOM\n * @param  rootElement - root DOM element. will be parsed inside the children of this element\n * @return result of parsing\n */\nexport function parseDOM(\n    config: ParserConfig,\n    rootElement?: Element\n): ParseDomResult {\n    if (config.type === \"string\") {\n        const parentElement = rootElement || window.document\n        if (!config.selector) {\n            return parseText(parentElement, config.parseFrom)\n        }\n        const targetElement = parentElement.querySelector<Element>(\n            config.selector\n        )\n        const value =  targetElement\n            ? parseText(targetElement, config.parseFrom)\n            : null\n        return config.formatter ? config.formatter(value, targetElement) : value\n    }\n    if (config.type === \"count\") {\n        const parentElement = rootElement || window.document\n        const targetElements = parentElement.querySelectorAll<Element>(\n            config.selector\n        )\n        return targetElements.length\n    }\n    if (config.type === \"number\") {\n        const parentElement = rootElement || window.document\n        if (!config.selector) {\n            const value = parseText(parentElement, config.parseFrom)\n            return config.formatter(value, parentElement)\n        }\n        const targetElement = parentElement.querySelector<Element>(\n            config.selector\n        )\n        const value = targetElement\n            ? parseText(targetElement, config.parseFrom) : null\n        return config.formatter(value, targetElement)\n    }\n\n    if (config.type === \"boolean\") {\n        const parentElement = rootElement || window.document\n        const targetElement = parentElement.querySelector<Element>(\n            config.selector\n        )\n        const targetElementExists = Boolean(targetElement)\n        return !config.inverse ? targetElementExists : !targetElementExists\n    }\n    if (config.type === \"array\") {\n        const parentElement = rootElement || window.document\n        const mathedElems = parentElement.querySelectorAll<Element>(\n            config.selector\n        )\n        if (config.items) {\n            const values = [] as ParseDomResult[]\n            for (const el of mathedElems) {\n                values.push(parseDOM(config.items, el))\n            }\n            return values\n        } else {\n            return [...mathedElems].map(\n                (el: Element) => parseText(el, config.parseFrom)\n            )\n        }\n    }\n    if (config.type === \"object\") {\n        const result = {} as { [key: string]: ParseDomResult }\n        for (const { key, value } of config.keys) {\n            result[key] = parseDOM(value, rootElement)\n        }\n        return result\n    }\n    return null\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\ntype EventHadler<P = any> = (p: P) => any\n\ntype Event = {\n    eventName: string\n    handlers: EventHadler[]\n}\n\n/* Simple EventEmitter */\nexport class EventEmitter {\n    private events: Event[] = []\n\n    private createUnwatcher<P = any>(\n        eventName: string,\n        handler: EventHadler<P>\n    ) {\n        return () => {\n            for (let i = 0; i < this.events.length; i++) {\n                const event = this.events[i]\n                event.handlers = event.handlers.filter(\n                    existingHandler => existingHandler !== handler\n                )\n                if (event.handlers.length) continue\n                this.events.splice(i, 1)\n                i--\n            }\n        }\n    }\n\n    public on<P = any>(eventName: string, handler: EventHadler<P>) {\n        const unwatch = this.createUnwatcher<P>(eventName, handler)\n\n        const existingEvent = this.events.find(\n            found => found.eventName === eventName\n        )\n        if (existingEvent && existingEvent.handlers.includes(handler)) {\n            return unwatch\n        } else if (existingEvent) {\n            existingEvent.handlers.push(handler)\n        } else {\n            this.events.push({ eventName, handlers: [handler] })\n        }\n        return unwatch\n    }\n\n    public off<P = any>(eventName: string, handler: EventHadler<P>) {\n        const unwatch = this.createUnwatcher(eventName, handler)\n        unwatch()\n    }\n\n    public dispatch<P = any>(eventName: string, payload?: P) {\n        const event = this.events.find(event => event.eventName === eventName)\n        if (event) {\n            for (const handler of event.handlers) {\n                handler(payload)\n            }\n        }\n    }\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\nimport { EventEmitter } from \"./EventEmitter\"\n\nconst MAIN_OBSERVER_CONFIG = {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: false,\n    characterDataOldValue: false,\n    attributeOldValue: false,\n}\n\ntype TargetElementDescriptor = {\n    name: string\n    selector: string\n    observerConfig?: MutationObserverInit\n}\n\ntype ObservedElement = {\n    element: Element\n    observer: MutationObserver\n}\n\ntype TargetElementsObserver = {\n    descriptor: TargetElementDescriptor\n    observedElements: ObservedElement[]\n}\n\n\nexport const FOUND_EVENT_NAME = \"target-element-found\"\nexport const MUTATED_EVENT_NAME = \"target-element-mutated\"\n\nexport type FoundEvent = {\n    type: typeof FOUND_EVENT_NAME\n    descriptor: TargetElementDescriptor\n    element: Element\n}\n\nexport type MutatedEvent = {\n    type: typeof MUTATED_EVENT_NAME\n    descriptor: TargetElementDescriptor\n    mutations: MutationRecord[]\n    element: Element\n}\n\nexport type ObserveDomEvent = FoundEvent | MutatedEvent\n\nexport type MainObserverCb = (mutations: MutationRecord[]) => void\n\ntype SubscribeCb = (e: ObserveDomEvent) => void\n\nexport class DomObserver extends EventEmitter {\n    private _mainObserver: MutationObserver | null = null\n    private _targetElementsObservers: TargetElementsObserver[] = []\n    private _targetElementsDescriptors: TargetElementDescriptor[] = []\n    private _checkTargetSelectorAndObserve(\n        descriptor: TargetElementDescriptor,\n        el: Element,\n        mutationsList: MutationRecord[],\n    ) {\n        const targetElements = [...el.querySelectorAll<Element>(descriptor.selector)]\n        if (el.matches(descriptor.selector)) {\n            targetElements.push(el)\n        }\n    \n        if (!targetElements.length) {\n            return\n        }\n\n        this._observeTargetElements(targetElements, descriptor)\n\n        // check if the mutation of the target node is in the mutations list\n        const targetElementsWithMutations = this._matchTargetElementMutations(\n            descriptor,\n            mutationsList\n        )\n        for (const { target, mutations } of targetElementsWithMutations) {\n            this._dispatchMutatedEvent(target, mutations, descriptor)\n        }\n    }\n    private _matchTargetElementMutations(\n        descriptor: TargetElementDescriptor,\n        mutationsList: MutationRecord[]\n    ) {\n        type TargetElementMutations = {\n            target: Element\n            mutations: MutationRecord[]\n        }\n\n        const targetElementsMutations: TargetElementMutations[] = []\n\n        for (const mutation of mutationsList) {\n            if (!(mutation.target instanceof Element)) continue\n            const target = mutation.target.closest(descriptor.selector)\n            if (!target) continue\n            const existing = targetElementsMutations.find(\n                (found) => found.target === target\n            )\n            if (existing) {\n                existing.mutations.push(mutation)\n            } else {\n                targetElementsMutations.push({\n                    target,\n                    mutations: [mutation],\n                })\n            }\n        }\n        return targetElementsMutations\n    }\n    private _observeTargetElements(\n        elems: Element[],\n        descriptor: TargetElementDescriptor\n    ) {\n        const existing = this._targetElementsObservers.find((found) => {\n            return found.descriptor === descriptor\n        })\n\n        const targetElementObservers: TargetElementsObserver = existing || {\n            descriptor,\n            observedElements: [],\n        }\n\n        if (!existing) {\n            this._targetElementsObservers.push(targetElementObservers)\n        }\n\n        for (const elem of elems) {\n            const alreadyObserved = targetElementObservers.observedElements.some(({ element }) => {\n                return element === elem\n            })\n            if (alreadyObserved) continue\n\n            const observer = new window.MutationObserver(mutations =>\n                this._onTargetElementMutated(elem, mutations, descriptor)\n            )\n            this._dispatchFoundEvent(descriptor, elem)\n            observer.observe(elem, descriptor.observerConfig)\n            targetElementObservers.observedElements.push({\n                element: elem,\n                observer,\n            })\n        }\n    }\n    private _onTargetElementMutated(\n        element: Element,\n        mutations: MutationRecord[],\n        descriptor: TargetElementDescriptor\n    ) {\n        this._dispatchMutatedEvent(element, mutations, descriptor)\n    }\n    private _dispatchMutatedEvent(\n        element: Element,\n        mutations: MutationRecord[],\n        descriptor: TargetElementDescriptor\n    ) {\n        const payload: MutatedEvent = {\n            type: MUTATED_EVENT_NAME,\n            descriptor,\n            mutations,\n            element,\n        }\n        this.dispatch(\"target-element-mutated\", payload)\n    }\n    private _dispatchFoundEvent(\n        descriptor: TargetElementDescriptor,\n        element: Element\n    ) {\n        const payload: FoundEvent = {\n            type: FOUND_EVENT_NAME,\n            descriptor,\n            element,\n        }\n        this.dispatch(\"target-element-found\", payload)\n    }\n    private _onRootElementMutated = (mutationsList: MutationRecord[]) => {\n        for (const mutation of mutationsList) {\n            if (mutation.type !== \"childList\") continue\n            for (const node of mutation.addedNodes) {\n                if (!(node instanceof window.Element)) continue\n                for (const descriptor of this._targetElementsDescriptors) {\n                    this._checkTargetSelectorAndObserve(\n                        descriptor,\n                        node,\n                        mutationsList\n                    )\n                }\n            }\n\n            this._clearObservedElementsByMutation(mutation)\n        }\n    }\n    private _clearObservedElementsByMutation(mutation: MutationRecord) {\n        if (!mutation.removedNodes || !mutation.removedNodes.length) {\n            return\n        }\n\n        for (const { descriptor, observedElements } of this._targetElementsObservers) {\n            for (let i = 0; i < observedElements.length; i++) {\n                const { element, observer } = observedElements[i]\n                if ([...mutation.removedNodes].includes(element)) {\n                    const unhandledRecords = observer.takeRecords()\n                    if (unhandledRecords.length) {\n                        this._onTargetElementMutated(\n                            element,\n                            unhandledRecords,\n                            descriptor\n                        )\n                    }\n                    observer.disconnect()\n                    observedElements.splice(i, 1)\n                    i--\n                }\n            }\n        }\n\n        for (let i = 0; i < this._targetElementsObservers.length; i++) {\n            const curr = this._targetElementsObservers[i]\n            if (!curr.observedElements.length) {\n                this._targetElementsObservers.splice(i, 1)\n                i--\n            }\n        }\n    }\n\n    private _clearObservedElementsByDescriptor(\n        descriptor: TargetElementDescriptor\n    ) {\n        const existingIndex = this._targetElementsObservers.findIndex((found) => {\n            return found.descriptor === descriptor\n        })\n\n        if (existingIndex === -1) return\n\n        const { observedElements } = this._targetElementsObservers[existingIndex]\n\n        // stop all observers\n        for (let i = 0; i < observedElements.length; i++) {\n            const { element, observer } = observedElements[i]\n            const unhandledRecords = observer.takeRecords()\n            if (unhandledRecords.length) {\n                this._onTargetElementMutated(\n                    element,\n                    unhandledRecords,\n                    descriptor\n                )\n            }\n            observer.disconnect()\n            observedElements.splice(i, 1)\n            i--\n        }\n    }\n    constructor(private _rootElement: Element = document.body) {\n        super()\n    }\n\n    get observed() {\n        return this._targetElementsObservers   \n    }\n\n    public start(cb?: MainObserverCb) {\n        this._mainObserver = new window.MutationObserver(mutations => {\n            this._onRootElementMutated(mutations)\n            if (cb) {\n                cb(mutations)\n            }\n        })\n        this._mainObserver.observe(this._rootElement, MAIN_OBSERVER_CONFIG)\n        return this\n    }\n    public stop() {\n        if (this._mainObserver) {\n            this._mainObserver.disconnect()\n            this._onRootElementMutated(this._mainObserver.takeRecords())\n            this._mainObserver = null\n        }\n        this.stopObservation()\n        return this\n    }\n    public subscribe(cb: SubscribeCb, descriptor?: TargetElementDescriptor) {\n        const handleEvent = (e: ObserveDomEvent) => {\n            if (!descriptor) {\n                cb(e)\n                return\n            }\n            if (descriptor.name === e.descriptor.name) {\n                cb(e)\n            }\n        }\n        this.on<MutatedEvent>(MUTATED_EVENT_NAME, handleEvent)\n        this.on<FoundEvent>(FOUND_EVENT_NAME, handleEvent)\n        return () => {\n            this.off(MUTATED_EVENT_NAME, handleEvent)\n            this.off(FOUND_EVENT_NAME, handleEvent)\n        }\n    }\n    public stopObservation(name?: string) {\n        for (let i = 0; i < this._targetElementsObservers.length; i++) {\n            const targetElementObserver = this._targetElementsObservers[i]\n            if (name && targetElementObserver.descriptor.name !== name) continue\n\n            this._clearObservedElementsByDescriptor(\n                targetElementObserver.descriptor\n            )\n            this._targetElementsObservers.splice(i, 1)\n            i--\n        }\n    \n        if (!name) {\n            this._targetElementsDescriptors = []\n            return this\n        }\n        const updatedDescriptors = this._targetElementsDescriptors.filter(\n            found => found.name !== name\n        )\n        this._targetElementsDescriptors = updatedDescriptors\n        return this\n    }\n    public observe(descriptor: TargetElementDescriptor) {\n        this._targetElementsDescriptors.push(descriptor)\n        // element already exists\n        const targetElements = [\n            ...this._rootElement.querySelectorAll<Element>(\n                descriptor.selector\n            ),\n        ]\n        if (targetElements.length) {\n            this._observeTargetElements(targetElements, descriptor)\n        }\n        return this\n    }\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\nimport { DomObserver, MainObserverCb, ObserveDomEvent } from \"./DomObserver\"\nimport { parseDOM, ParserConfig, ParseDomResult } from \"./DomParser\"\n\nexport type DomCollectorTarget = {\n    name: string\n    targetSelector: string\n    guardSelector?: string\n    childGuardSelector?: string\n    guard?: (rootElement: Element) => boolean\n    parseRootEl?: string | Element\n    observeConfig?: MutationObserverInit\n    parseConfig: ParserConfig\n    payload?: any\n    mapResult?: (parsedContent: any) => any\n}\n\ntype DomCollectorResult = {\n    name: string\n    payload?: any\n    originalEvent?: ObserveDomEvent\n    parsedContent: any\n}\n\ntype Params = {\n    targets: DomCollectorTarget[]\n    onCollect: (result: DomCollectorResult) => void\n    rootEl?: Element\n    mainObserverCallback?: MainObserverCb\n}\n\nconst DEFAULT_OBSERVER_CONFIG = {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: false,\n    characterDataOldValue: false,\n    attributeOldValue: false,\n}\n\nexport const createDomCollector = ({\n    targets,\n    onCollect,\n    rootEl,\n    mainObserverCallback,\n}: Params) => {\n    const domObserver = new DomObserver(rootEl || document.body)\n    \n    domObserver.start(mainObserverCallback)\n    \n    for (const target of targets) {\n        const { mapResult } = target\n\n        const observeDescriptor = {\n            name: target.name,\n            selector: target.targetSelector,\n            observerConfig: target.observeConfig || DEFAULT_OBSERVER_CONFIG,\n        }\n        domObserver.subscribe((e) => {\n            const { element } = e\n            const { guardSelector, childGuardSelector, guard } = target\n            if (!guardSelector || document.querySelector(guardSelector)) {\n                let parseRootEl: Element | undefined | null\n                if (target.parseRootEl) {\n                    parseRootEl =\n                        typeof target.parseRootEl === \"string\"\n                            ? document.querySelector<Element>(\n                                target.parseRootEl\n                            )\n                            : target.parseRootEl\n                } else {\n                    parseRootEl = element\n                }\n\n                if (!parseRootEl) {\n                    return\n                }\n\n\n                if (childGuardSelector \n                    && !parseRootEl.querySelector(childGuardSelector)) {\n                    return\n                }\n\n                if (guard && !guard(parseRootEl)) {\n                    return\n                }\n\n                const parsedContent = parseDOM(target.parseConfig, parseRootEl)\n                onCollect({\n                    name: target.name,\n                    payload: target.payload,\n                    originalEvent: e,\n                    parsedContent: mapResult\n                        ? mapResult(parsedContent)\n                        : parsedContent,\n                })\n            }\n        }, observeDescriptor)\n        domObserver.observe(observeDescriptor)\n    }\n\n    return domObserver\n}\n"],"names":["parseText","el","parseFrom","Element","getAttribute","textContent","parseDOM","config","rootElement","type","parentElement","window","document","selector","targetElement","querySelector","value","formatter","querySelectorAll","length","targetElementExists","Boolean","inverse","mathedElems","items","values","push","map","result","key","keys","EventEmitter","[object Object]","this","eventName","handler","i","events","event","handlers","filter","existingHandler","splice","unwatch","createUnwatcher","existingEvent","find","found","includes","payload","MAIN_OBSERVER_CONFIG","attributes","childList","subtree","characterData","characterDataOldValue","attributeOldValue","FOUND_EVENT_NAME","MUTATED_EVENT_NAME","DomObserver","_rootElement","body","super","mutationsList","mutation","node","addedNodes","descriptor","_targetElementsDescriptors","_checkTargetSelectorAndObserve","_clearObservedElementsByMutation","targetElements","matches","_observeTargetElements","targetElementsWithMutations","_matchTargetElementMutations","target","mutations","_dispatchMutatedEvent","targetElementsMutations","closest","existing","elems","_targetElementsObservers","targetElementObservers","observedElements","elem","some","element","observer","MutationObserver","_onTargetElementMutated","_dispatchFoundEvent","observe","observerConfig","dispatch","removedNodes","unhandledRecords","takeRecords","disconnect","existingIndex","findIndex","observed","cb","_mainObserver","_onRootElementMutated","stopObservation","handleEvent","e","name","on","off","targetElementObserver","_clearObservedElementsByDescriptor","updatedDescriptors","DEFAULT_OBSERVER_CONFIG","createDomCollector","targets","onCollect","rootEl","mainObserverCallback","domObserver","start","mapResult","observeDescriptor","targetSelector","observeConfig","subscribe","guardSelector","childGuardSelector","guard","parseRootEl","parsedContent","parseConfig","originalEvent"],"mappings":"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"}